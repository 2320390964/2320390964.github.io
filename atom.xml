<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astar</title>
  
  <subtitle>Astar&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-28T06:35:54.791Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试题目整理——css篇</title>
    <link href="http://example.com/2020/12/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94css%E7%AF%87/"/>
    <id>http://example.com/2020/12/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94css%E7%AF%87/</id>
    <published>2020-12-25T02:39:14.000Z</published>
    <updated>2020-12-28T06:35:54.791Z</updated>
    
    <content type="html"><![CDATA[<p>1.<strong>css选择器</strong></p><ul><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div, h1, p)</li><li>直接相邻选择器(h1 + p)、普通相邻选择器（h1~p）</li><li>子选择器（ul &gt; li）、后代选择器（li a）</li><li>通配符选择器（*）</li><li>属性选择器（a[rel=”external”]）</li><li>伪类选择器（a:hover, li:nth-child）</li></ul><p><strong>css选择器之组合选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>E,F</td><td>多元素选择器</td><td>同时匹配元素E或元素F</td></tr><tr><td>E F</td><td>后代选择器</td><td>匹配E元素所有的后代（不只是子元素、子元素向下<code>递归</code>）元素F</td></tr><tr><td>E&gt;F</td><td>子元素选择器</td><td>匹配E元素的所有<code>直接</code>子元素</td></tr><tr><td>E+F</td><td><code>直接相邻</code>选择器</td><td>匹配E元素之后的相邻的同级元素F</td></tr><tr><td>E~F</td><td>普通相邻选择器（弟弟选择器）</td><td>匹配E元素之后的同级元素F（<code>无论直接相邻与否</code>)</td></tr><tr><td><strong>css选择器之伪类选择器</strong></td><td></td><td></td></tr></tbody></table><blockquote><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p></blockquote><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:focus</td><td>input:focus</td><td>选择元素输入后具有焦点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择所有选中的表单元素</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择只读属性的元素属性</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择没有只读属性的元素属性</td></tr><tr><td>:disabled</td><td>input:checked</td><td>选择所有禁用的表单元素</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择所有启用的表单元素</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择元素指定范围内的值</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择指定范围以外的值的元素属性</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择所有有效值的属性</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择所有无效的元素</td></tr><tr><td>:required</td><td>input:required</td><td>选择有”required”属性指定的元素属性</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择没有”required”的元素属性</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择所有没有子元素的p元素</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择每个父元素是p元素的第一个p子元素</td></tr><tr><td>:last-of-type</td><td>p:first-of-type</td><td>选择每个p元素是其父元素的最后一个p元素</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>匹配第一个p元素</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>匹配最后一个p元素</td></tr><tr><td>:not</td><td><code>:not(p)</code></td><td>选择所有p以外的元素</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择所有仅有一个子元素的p元素</td></tr><tr><td>:nth-child</td><td>p:nth-child(2)</td><td>选择所有p元素的第二个子元素</td></tr><tr><td>:nth-last-child</td><td>p:nth-last-child(2)</td><td>选择所有p元素倒数的第二个子元素</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择所有仅有一个子元素为p的元素</td></tr><tr><td>:nth-of-type</td><td>p:nth-of-type(2)</td><td>选择所有p元素第二个为p的子元素</td></tr><tr><td>:nth-last-of-type</td><td>p:nth-last-of-type(2)</td><td>选择所有p元素倒数的第二个为p的子元素</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未访问链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>把鼠标放在链接上的状态</td></tr><tr><td>:active</td><td>a:active</td><td>选择正在活动链接</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr><tr><td>:root</td><td>root</td><td>选择文档的根元素</td></tr><tr><td>:lang</td><td>q:lang(no){quotes: “<del>“ “</del>“}</td><td>为不同的语言匹配特殊的规则</td></tr><tr><td><strong>css选择器之伪元素选择器</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>选择器</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>::before/:before</td><td>在被选元素前插入内容。</td><td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td></tr><tr><td>::after/:after</td><td>在选被元素后插入内容</td><td>其用法和特性与:before相似。</td></tr><tr><td>::first-letter/:first-letter</td><td>匹配元素中文本的首字母。</td><td>被修饰的首字母不在文档树中。</td></tr><tr><td>::first-line/:first-line</td><td>匹配元素中第一行的文本。</td><td>这个伪元素只能用在块元素中，不能用在内联元素中。</td></tr><tr><td>::selection</td><td>::selection匹配用户被用户选中或者处于高亮状态的部分</td><td>在火狐浏览器使用时需要添加-moz前缀。该伪元素只支持双冒号的形式。</td></tr><tr><td>::placeholder</td><td>::placeholder匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效。</td><td>该伪元素不是CSS的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10和Firefox18及其以下版本）会使用单冒号的形式。</td></tr><tr><td>::backdrop(处于试验阶段)</td><td>::backdrop用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色</td><td>该伪元素只支持双冒号的形式</td></tr></tbody></table><p><strong>css选择器之属性选择器</strong><br>|选择器    |示例    |示例说明|<br>|—|—-|—|<br>|[attribute]|a[target]|用于选择具有指定属性的元素|<br>|[attribute=”value”]|a[target=”_blank”]|用于选择具有指定属性和值的元素|<br>|[attribute<del>=”value”]|[title</del>=”flower”]|于选择包含指定单词的属性值的元素|<br>|[attribute|=”value”]|[class|=”top”]|用于选取带有以指定值(此处<code>top-</code>)开头的属性值的元素|<br>|[attribute^=”value”]|[class^=”top”]|用于选择属性值以指定值(此处<code>top</code>)<code>开始</code>的元素|<br>|[attribute$=”value”]|[class$=”test”]|用于选择属性值以指定值结束的元素|<br>|[attribute*=”value”]|[class*=”te”]|用于选择属性值包含指定值的元素|<br>2. <strong>清除浮动</strong><br>父元素没有设置高度，子元素浮动会导致父元素坍塌，清除浮动可以解决。</p><ul><li>在浮动元素后添加一个空标签<code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</code>，并且在CSS中设置.clear{clear:both;}，即可清理浮动。<br><img src="https://img-blog.csdn.net/20180508002147876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>原理：添加一个空标签，利用CSS提高的clear:both清除浮动，让父元素可以自动获取到高度<br>优点：简单，代码少，兼容所有浏览器<br>缺点：增加页面的标签，造成结构的混乱<br>建议：不推荐使用，此方法已经过时</li><li>父级元素定义：<code>overflow:auto;zoom:1</code></li><li><strong>:after伪元素</strong>===&gt;给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素之后添加一个看不见的块元素（Block element）清理浮动。<br><img src="https://img-blog.csdn.net/20180508002527414?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  原理：通过CSS伪元素在容器的内部元素之后添加一个看不见的空格“/20”或点“.” ，并且设置clear属性清除浮动。<br>  优点：浏览器支持较好<br>  缺点：clearfix这个class需要添加zoom: 1（触发haslayout），才能支持IE6和IE7浏览器<br>  建议：推荐使用，设置公共类，减少CSS代码</li></ul><ol start="3"><li><p><strong>盒子模型</strong><br>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p></li><li><p><strong>css中可以继承的样式</strong><br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height</p></li><li><p><strong>优先级</strong><br>优先级（就近原则）：!important &gt; [ id &gt; class = 伪类 &gt; tag ]<br>!important比内联样式优先级还高，继承得到的样式优先</p></li><li><p><strong>display有哪些值？说明他们的作用?</strong><br>inline（默认）–内联<br>none–隐藏<br>block–块显示<br>table–表格显示<br>list-item–项目列表<br>inline-block</p></li><li><p><strong>当margin-top、padding-top的值是百分比时，分别是如何计算的？</strong><br>对元素的margin设置百分数，是相对于<code>父元素</code>的<code>width</code>计算的，不管是margin-top/margin-bottom/margin-left还是margin-right。（padding同理）</p></li><li><p><a href="https://blog.csdn.net/Tracy_frog/article/details/77509450">固定左右侧宽度，中间自适应布局</a></p></li><li><p><strong>css3,html5,es6的新特性</strong><br><a href="https://www.jianshu.com/p/d61bf4f36235">css3新特性</a><br><a href="https://github.com/2320390964/notes/issues/2">html5的新特性</a><br><a href="http://imweb.io/topic/55e330d6771670e207a16bbb">es6的新特性</a><br>let/const、class、扩展运算符、rest参数、模板字符串、Set、变量的解构赋值、Symbol（一种新的原始数据类型，表示独一无二的ID，它通过Symbol函数生成）</p></li><li><p><strong>display:none与visibility：hidden的区别？</strong><br>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p></li><li><p><strong>CSS优化、提高性能的方法有哪些？</strong></p><blockquote><p>避免过度约束<br>避免后代选择符<br>避免链式选择符<br>使用紧凑的语法<br>避免不必要的命名空间<br>避免不必要的重复<br>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么<br>避免！important，可以选择其他选择器<br>尽可能的精简规则，你可以合并不同类里的重复规则</p></blockquote></li></ol><p>10.<strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong><br>响应式网站设计(Responsive Web design)是<strong>一个网站能够兼容多个终端</strong>，而不是为每一个终端做一个特定的版本。</p><p>实现方法：</p><ul><li><p>媒体查询media，基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。pc端和移动端使用同一个项目，使用媒体查询实现响应式。缺点是要写很多样式，十分复杂。</p></li><li><p>rem，pc端使用固定布局，移动端使用rem等比缩放布局。可用media做微调。</p></li><li><p>flex。</p></li><li><p>vh/vw，视口的百分比。百分比布局。</p></li><li><p>响应式网页设计之<strong>viewport</strong><br>Viewport 是用户网页的可视区域。<br>Viewport 随设备而异，在移动手机上比在电脑屏幕上要小。<br>在平板电脑和移动手机之前，网页只为电脑屏幕设计，网页的静态设计和固定大小是很常见的。<br>然后，当我们开始使用平板电脑和手机上网的时候，固定大小的网页太大了，不适合观看。为了解决这个问题，这些设备上的浏览器<code>缩小了整个网页</code>以适应屏幕。<br>这并不完美！但可快速修复。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0, maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>  &lt;meta&gt; 窗口元素为浏览器提供了如何控制页面尺寸和缩放的说明。<br>  width=device-width 部分将页面的宽度设置为跟随设备的屏幕宽度（其将根据设备变化而变化）。<br>  initial-scale=1.0 部分设置浏览器首次加载页面时的初始缩放级别。</p></li><li><p><strong>网格视图</strong><br>前端使用过bootstrap框架的朋友们应该很清除介个东西，所谓网格视图，是把网页分割为n列，通常是 12 列，宽度为100%，平分下来每列为8.33%，在浏览器窗口大小调整时会自动伸缩。</p></li><li><p><strong>媒体查询</strong><br>网格视图可以很好的做到同缩同放，但是，当屏幕变得很小的时候，网页缩得很小，一个小屏幕一行挤入那么多内容，对用户显得很不友好。<br>我们想<code>有重点地显示</code>,怎么做呢？<br>使用媒体查询可以做到： 假设一个网页分为左右两面，如图（左侧导航右侧内容）<br><img src="https://img-blog.csdn.net/20181003170205796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li></ul><p>手机屏幕下，全部显示会显得很拥挤，如果左侧导航不显示就好了，像这样<br><img src="https://img-blog.csdn.net/20181003170403257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>是不是好多了~简单实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏幕大小小于768px时候</span><br><span class="line">.left &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">.left &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>网格和媒体查询结合</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* For mobile phones: *&#x2F;</span><br><span class="line">[class*&#x3D;&quot;col-&quot;] &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">    &#x2F;* For desktop: *&#x2F;</span><br><span class="line">    .col-1 &#123;width: 8.33%;&#125;</span><br><span class="line">    .col-2 &#123;width: 16.66%;&#125;</span><br><span class="line">    .col-3 &#123;width: 25%;&#125;</span><br><span class="line">    .col-4 &#123;width: 33.33%;&#125;</span><br><span class="line">    .col-5 &#123;width: 41.66%;&#125;</span><br><span class="line">    .col-6 &#123;width: 50%;&#125;</span><br><span class="line">    .col-7 &#123;width: 58.33%;&#125;</span><br><span class="line">    .col-8 &#123;width: 66.66%;&#125;</span><br><span class="line">    .col-9 &#123;width: 75%;&#125;</span><br><span class="line">    .col-10 &#123;width: 83.33%;&#125;</span><br><span class="line">    .col-11 &#123;width: 91.66%;&#125;</span><br><span class="line">    .col-12 &#123;width: 100%;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 结合CSS媒体查询,可以创建适应不同设备的方向(横屏landscape、竖屏portrait等)的布局</span><br><span class="line">&#x2F;&#x2F; 如果是竖屏背景将是浅蓝色：</span><br><span class="line">@media only screen and (orientation: landscape) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="11"><li><p>使用flex布局搭配百分比很容易实现自适应的多行多列<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p></li><li><p>移动端web页面适配方案（经典）（将viewport的scale设为设备像素比dpr的倒数+rem）<br>viewport=&gt;缩放到合适的大小<br>rem=&gt;根据不同大小的屏幕修改内容大小（大屏东西大，小屏东西小）<br><a href="https://www.jianshu.com/p/e5ca5b78e03e">https://www.jianshu.com/p/e5ca5b78e03e</a><br><a href="https://segmentfault.com/a/1190000008767416">https://segmentfault.com/a/1190000008767416</a><br>根据设备像素比设置viewport的缩放大小（实现高清），再配合rem适配（大屏大字，小屏小字）。</p></li><li><p>rem实现移动端自适应<br><a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/</a><br><a href="http://caibaojian.com/flexible-js.html">http://caibaojian.com/flexible-js.html</a></p></li><li><p>1px边框问题</p></li><li><p>BFC（格式化上下文）<br><a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><blockquote><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><pre><code>body 根元素浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll)</code></pre></blockquote></li><li><p><a href="https://www.cnblogs.com/coco1s/p/4444383.html">居中布局的实现</a></p></li></ol>]]></content>
    
    
    <summary type="html">哈哈哈</summary>
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目整理——计算机网络基础篇（汇总）</title>
    <link href="http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/"/>
    <id>http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E6%B1%87%E6%80%BB%EF%BC%89/</id>
    <published>2020-12-24T03:08:40.000Z</published>
    <updated>2020-12-28T02:43:33.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考：在浏览器中，一个页面从输入URL到加载完成，有哪些步骤？"><a href="#思考：在浏览器中，一个页面从输入URL到加载完成，有哪些步骤？" class="headerlink" title="思考：在浏览器中，一个页面从输入URL到加载完成，有哪些步骤？"></a>思考：在浏览器中，一个页面从输入URL到加载完成，有哪些步骤？</h1><ol><li>域名解析（DNS协议，将<code>符合人类记忆习惯</code>的域名解析为<code>计算机可理解</code>的服务器的IP地址)</li><li>建立TCP连接，浏览器与服务器进行<code>3次握手</code>建立连接</li><li>浏览器发起http请求，发送请求数据</li><li>tcp将<code>http请求报文</code>切割为<code>报文段</code>，并在各个报文上打上标记序号以及端口号，将每个报文段可靠地传给<code>网络层</code></li><li>ip协议在<code>网络层</code>通过ip地址找到mac地址（<code>ARP协议</code>，解析地址，根据通信方的ip地址反查出对应的MAC地址），在各个路由中间进行<code>路由中转</code>传送到<code>数据链路层</code></li><li>服务器端在数据链路层收到数据，按数据链路层→网络层→传输层→应用层顺序逐层发送数据，期间，之前加在数据报上的报头信息被层层解析丢弃。</li><li>服务器响应http请求，发送响应数据<br>….同上述过程发送</li><li>浏览器收到响应数据，<a href="https://juejin.im/post/6844903565610188807#heading-0">渲染页面</a>，解析收到的html、css和js文件等等</li></ol><h1 id="关于TCP-IP网络模型"><a href="#关于TCP-IP网络模型" class="headerlink" title="关于TCP/IP网络模型"></a>关于TCP/IP网络模型</h1><ol><li>dns、http、tcp、ip协议等都是<code>通信协议</code>，也就是通信时所遵守的规则，只有双方按照这个规则“说话”，对方才能理解或为之服务。</li><li>这里我们有必要先了解下<code>TCP/IP协议族</code>，通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。<br>TCP/IP模型包含四层结构：网络接口层(数据链路层)、网络层、传输层和应用层。<blockquote><p>把TCP/IP层次化是有好处的。比如，如果互联网只由一个协议统筹，当某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p></blockquote></li></ol><p><img src="https://img-blog.csdnimg.cn/20190118152318974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TCP/IP 协议可以为各式各样的应用提供服务（所谓的<code> everything over IP</code>），同时<br>TCP/IP 协议也允许 IP 协议在各式各样的网络构成的互联网上运行（所谓的 <code>IP over everything</code>）<br><img src="https://img-blog.csdnimg.cn/20190118154150708.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3. 在<strong>应用层</strong>有FTP、<strong>HTTP</strong>、TELNET、SMTP、DNS等协议。<br>在<strong>传输层</strong>中有TCP协议与UDP协议。<br>在<strong>网络层</strong>有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</p><h3 id="URL和URI的结构与区别"><a href="#URL和URI的结构与区别" class="headerlink" title="==URL和URI的结构与区别=="></a>==URL和URI的结构与区别==</h3><ol><li><p>URL(统一资源定位符)</p><blockquote><p>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址</p></blockquote><p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;...&#x2F;[?query-string][#anchor]</span><br><span class="line">scheme               指定低层使用的协议(例如：http, https, ftp)</span><br><span class="line">host                   HTTP服务器的IP地址或者域名</span><br><span class="line">port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http:&#x2F;&#x2F;www.cnblogs.com:8080&#x2F;</span><br><span class="line">path                   访问资源的路径</span><br><span class="line">query-string       发送给http服务器的数据</span><br><span class="line">anchor-             锚</span><br></pre></td></tr></table></figure><p>以下为url的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mywebsite.com&#x2F;sj&#x2F;test&#x2F;test.aspx?name&#x3D;sviergn&amp;x&#x3D;true#stuff</span><br><span class="line"></span><br><span class="line">Schema:                 http</span><br><span class="line">host:                   www.mywebsite.com</span><br><span class="line">path:                   &#x2F;sj&#x2F;test&#x2F;test.aspx</span><br><span class="line">Query String:           name&#x3D;sviergn&amp;x&#x3D;true</span><br><span class="line">Anchor:                 stuff</span><br></pre></td></tr></table></figure></li><li><p>URI(统一资源标识符)</p></li><li><p><a href="https://segmentfault.com/a/1190000006081973">区别</a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="==HTTP协议=="></a>==HTTP协议==</h3></li><li><p>HTTP是<strong>应用层协议</strong>，当你上网浏览网页的时候，<strong>浏览器和Web服务器</strong>之间就会通过HTTP在Internet上进行数据的发送和接收。HTTP是一个基于<strong>请求/响应模式</strong>的、<strong>无状态</strong>的、<strong>连接持久</strong>的协议。</p></li><li><p><strong>无状态</strong>意味着自身不会对请求和响应之间的通信状态进行保存。即每个请求都是独立的，服务器并不会保留上次请求的数据。</p></li><li><p>早期的http版本中，每进行一次http通信都要断开一次tcp连接，这无疑会增加通信的开销，特别是网络信息丰富多彩的今天，大量的图片请求将会造成巨大的通信开销。为了解决上述问题，加速页面加载，http/1.1提出了持久连接，只要任意一端没有明确提出断开连接，则保持tcp连接状态，连接开销由N个RTT时间减少到一个。</p></li><li><p>管线化。从前发送请求后需等待并收到响应，才能发送下一个请求，管线化技术出现后，不用等待就能并行发送多个请求。（这得益于<code>持久连接</code>的出现）</p></li><li><p><a href="https://blog.csdn.net/Tracy_frog/article/details/82903513?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158722179219724843308368%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=158722179219724843308368&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-1">HTTP请求的几种方式</a></p></li><li><p><a href="https://blog.csdn.net/Tracy_frog/article/details/83537488">HTTP状态码</a></p></li><li><p><a href="https://blog.csdn.net/Tracy_frog/article/details/105600386">HTTP报文</a></p><h3 id="TCP和UDP协议"><a href="#TCP和UDP协议" class="headerlink" title="==TCP和UDP协议=="></a>==TCP和UDP协议==</h3></li><li><p>tcp协议的三次握手和四次挥手探究<br>假设两次握手，当<strong>失效的连接请求报文段</strong>突然又传送到服务端，它以为客户端又请求了，就发确认邮件到客户端，客户端一看，这不是我去年发的吗，就不理它了，服务器端却以为连接已经建立了，等等等，浪费服务器资源。<br><a href="http://www.cnblogs.com/shijingxiang/articles/4446750.html">网络TCP建立连接为什么需要三次握手而结束要四次</a></p></li><li><p>udp协议（User Data Protocol，用户数据报协议）<br>（1） UDP是一个<strong>非连接</strong>的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。<br>（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。<br>（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。<br>（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。<br>（5）UDP使用尽最大努力交付，即<strong>不保证可靠交付</strong>，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。<br>（6）UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p></li><li><p>TCP与UDP的区别</p><ul><li>基于连接与无连接； </li><li>对系统资源的要求（TCP较多，UDP少）； </li><li>UDP程序结构较简单； </li><li>流模式与数据报模式 ；</li><li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证<h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="==DNS协议=="></a>==DNS协议==</h3></li></ul></li></ol><h3 id="SOCKET"><a href="#SOCKET" class="headerlink" title="==SOCKET=="></a>==SOCKET==</h3><p><strong>socket</strong>是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。socket只是一种连接模式，不是协议,tcp,udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的，.用socket可以创建tcp连接，也可以创建udp连接，这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。</p><h3 id="扩展：OSI七层协议"><a href="#扩展：OSI七层协议" class="headerlink" title="==扩展：OSI七层协议=="></a>==扩展：OSI七层协议==</h3><p><img src="https://img-blog.csdnimg.cn/20190118141738345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>应用层</strong>：直接为<strong>用户</strong>的应用进程提供服务，如 HTTP、支持文件传输的 FTP 协议等</p><p><strong>运输层</strong>：向两个<strong>主机</strong>中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务。分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程。运输层主要使用以下两种协议：1.传输控制协议TCP（数据传输的单位是<strong>报文段</strong>）2.用户数据报协议UDP（数据传输的单位是<strong>用户数据报</strong>），不保证提供可靠的交付，只能提供“尽最大努力交付”</p><p><strong>网络层</strong>：使用无连接的网际协议 IP 和许多种路由选择协议。负责为分组交换网上的不同主机提供通信服务，把运输层产生的报文段或用户数据报封装成分组（也叫<strong>IP数据报或数据报</strong>）或包进行传送。网络层的另一个任务就是<strong>选择合适的路由</strong>。</p><p><strong>数据链路层（链路层）</strong>：将网络层交下来的 IP 数据报组装成<strong>帧</strong>，在两个相邻结点（主机和路由器，或两个路由器）之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。<br>（透明表示无论什么样的比特组合的数据都能够通过这个数据链路层）<br>如发现有差错，会简单的丢弃帧。如果需要改正错误，由运输层的 TCP 来完成。</p><p><strong>物理层</strong>：传送数据的单位是<strong>比特</strong>。物理层的任务就是透明地传送比特流。<br>要考虑用多大的电压代表“1” 或 ”0”，以及接受方如何识别出发送方所发的比特。还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。<br>当然，哪几个比特代表什么意思，则不是物理层所要管的。<br>请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体层当作第0层。<br><img src="https://img-blog.csdnimg.cn/20190118152139443.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第2层（数据链路层）数据单元 PDU 的首尾都要加上控制信息。<br>物理层不需要加控制信息，但要注意传送比特流时应从首部开始传送。</p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="==安全问题=="></a>==安全问题==</h3><p><strong>sql注入</strong>：利用引号截断sql语句<br>防御：用户输入进行过滤，sql语句预处理。</p><p><strong>xss</strong>：理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script（改变样式什么的）。（可以盗取用户cookie)<br><a href="https://blog.csdn.net/ghsau/article/details/17027893">XSS攻击及防御</a><br>开发者对用户输入进行处理，个人不要随便点击连接。<br>vue、react等框架已经很好的预防了xss攻击，除非使用v-html将用户输入直接放到页面中。</p><p><strong>csrf</strong>：伪造请求，冒充用户在站内的正常操作。<br>要完成一次CSRF攻击，受害者必须依次完成两个步骤：<br>1.登录受信任网站A，并在本地生成Cookie。<br>2.在不登出A的情况下，访问危险网站B。</p><p><a href="http://netsecurity.51cto.com/art/201407/446775.htm">科普：对于XSS和CSRF你究竟了解多少</a><br><a href="https://juejin.im/post/5bb2d1c1e51d450e5162a865">前端必须懂的计算机网络知识—(XSS、CSRF和HTTPS)</a><br><a href="https://desert3.iteye.com/blog/869080">HttpOnly介绍以及防止XSS攻击时的作用(转)</a></p><p>【来源与参考】<br>上野宣, 于均良. 图解HTTP:HTTP[J]. 2014.<br><a href="http://www.cnblogs.com/xhwy/archive/2012/03/03/2378293.html?utm_source=caibaojian.com">通信协议——Http、TCP、UDP</a><br><a href="http://www.runoob.com/http/http-messages.html">HTTP消息结构</a><br><a href="https://my.oschina.net/leejun2005/blog/136820">关于 HTTP GET/POST 请求参数长度最大值的一个理解误区</a><br><a href="https://blog.csdn.net/qq_18425655/article/details/52314970">面试题：OSI七层协议和TCP/IP四层协议</a><br><a href="http://www.cnblogs.com/shijingxiang/articles/4446750.html">网络TCP建立连接为什么需要三次握手而结束要四次</a><br><a href="https://blog.csdn.net/qq_18425655/article/details/51955674">面试题：TCP协议与UDP协议的区别</a><br><a href="https://segmentfault.com/a/1190000010076454">前端应该掌握的网络知识（一）</a></p>]]></content>
    
    
    <summary type="html">常见前端面试网络题目</summary>
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目整理——http请求的几种方式</title>
    <link href="http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-12-24T03:06:47.000Z</published>
    <updated>2020-12-28T06:35:58.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP请求的方式"><a href="#HTTP请求的方式" class="headerlink" title="HTTP请求的方式"></a>HTTP请求的方式</h3><p>post和get这类常见的请求大家应该都不陌生。<br>事实上，http有以下几种请求：</p><ul><li><code>GET</code>  ：获取资源<br>请求获取由Request-URI所标识的资源，get请求会在URL中显示请求的资源，一般只用于数据的读取</li><li><code>POST</code> ：传输实体主体<br>在Request-URI所标识的资源后<code>附加新的数据</code>。</li><li><code>PUT</code> ：传输文件<br>请求服务器存储一个资源，并用Request-URI作为其标识。PUT请求会向指定资源位置上传其<code>最新内容</code>，PUT方法是幂等的方法。<code>通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容</code>。</li><li><code>DELETE</code> ：删除文件<br>请求服务器删除由Request-URI所标识的资源。DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。<code>DELETE请求后指定资源会被删除</code>，DELETE方法也是幂等的。</li><li> <code>HEAD</code> ：获得响应报文首部<br>请求获取由Request-URI所标识的资源的<code>响应消息报头</code>。HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时<code>不会</code>回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以<code>获取服务器的响应头信息</code>。HEAD方法常被用于客户端<code>查看服务器的性能</code>。也可用于确认URI的有效性及资源更新的日期时间等。</li><li><code>OPTIONS</code> ：询问支持的方法<br>用来查询针对请求URI指定的资源支持的方法。请求查询服务器的性能，或查询与资源相关的选项和需求。OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回<code>该资源所支持的所有HTTP请求方法</code>，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 </li><li><code>TRACE </code>：追踪路径<br>请求服务器回送收到的请求信息，主要用于测试或诊断。TRACE请求服务器<code>回显其收到的请求信息</code>，<code>该方法主要用于HTTP请求的测试或诊断</code>。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。</li><li><code>CONNECT </code>：要求用隧道协议连接代理<br>能够将连接改为<code>管道方式</code>的代理服务器。通常用于<code>SSL</code>加密服务器的链接与非加密的HTTP代理服务器的通信。</li></ul><h3 id="HTTP协议之Get和Post"><a href="#HTTP协议之Get和Post" class="headerlink" title="HTTP协议之Get和Post"></a>HTTP协议之Get和Post</h3><p>我们看看GET和POST的区别</p><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对<strong>URL的长度</strong>有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li><li><p>多数浏览器对于POST分两个package发送数据，请求头和请求体分开发，即使参数再少再短，也会被分成两个步骤来发送（相对于GET），也就是第一步发送header数据，第二步再发送body部分。HTTP是应用层的协议，而在传输层有些情况TCP会出现两次连结的过程，HTTP协议本身不保存状态信息，一次请求一次响应。对于TCP而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用GET请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。</p></li></ol><h3 id="什么情况下会发送options请求"><a href="#什么情况下会发送options请求" class="headerlink" title="什么情况下会发送options请求"></a>什么情况下会发送options请求</h3><p><code>在跨域情况下</code>，当一个请求为<code>非简单请求</code>就会发送options请求</p><p>满足以下条件就是一个简单请求:</p><ul><li>Method: 请求的方法是 GET、POST 及 HEAD</li><li>Header: 请求头是 Content-Type、Accept-Language、Content-Language 等</li><li>Content-Type: 请求类型是 application/x-www-form-urlencoded、multipart/form-data 或 text/plain</li></ul><blockquote><p>而在项目中常见的 Content-Type: application/json 及 Authorization: <token> 为典型的「非简单请求」，在发送请求时往往会带上 Options</p></blockquote>]]></content>
    
    
    <summary type="html">HTTP请求的方式</summary>
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目整理——http状态码</title>
    <link href="http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2020-12-24T03:01:47.000Z</published>
    <updated>2020-12-28T06:36:08.492Z</updated>
    
    <content type="html"><![CDATA[<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。</p><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>1XX</td><td>信息响应，表示服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2XX</td><td>成功响应，操作被成功接收并处理</td></tr><tr><td>3XX</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5XX</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h2 id="状态码列表"><a href="#状态码列表" class="headerlink" title="状态码列表"></a>状态码列表</h2><table><thead><tr><th align="center">状态码</th><th align="center">英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"><code>200</code></td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center"><code>204</code></td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center"><code>206</code></td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center"><code>301</code></td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center"><code>302</code></td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center"><code>303</code></td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center"><code>304</code></td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会<code>缓存</code>访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center"><code>307</code></td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center"><code>400</code></td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center"><code>401</code></td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center"><code>403</code></td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center"><code>404</code></td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center"><code>405</code></td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">equest Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center"><code>500</code></td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center"><code>502</code></td><td align="center">Bad Gateway</td><td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td align="center"><code>503</code></td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center"><code>504</code></td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">http状态码汇总</summary>
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目整理——http协议请求报文和响应报文</title>
    <link href="http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/"/>
    <id>http://example.com/2020/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/</id>
    <published>2020-12-24T02:17:44.000Z</published>
    <updated>2020-12-28T06:36:03.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP的Request-Response"><a href="#一、HTTP的Request-Response" class="headerlink" title="一、HTTP的Request/Response"></a>一、HTTP的Request/Response</h2><p>先看<code>Request </code>消息（客户端发送）的结构,   Request 消息分为3部分<br>第一部分叫请求行（Request line）, 第二部分叫请求头（Request header）,第三部分是报文主体（body）. header和body之间有个空行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求行 &#x3D; 请求方法 + 请求URI + HTTP版本号</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190118104803876.png" alt="在这里插入图片描述"><br>再看<code>Response</code>消息（服务器端发送）的结构，Response消息分为3部分<br>第一部分叫状态行，第二部分叫响应头，第三部分是响应主体，header和body之间有个空行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态行 &#x3D; HTTP版本号 + 状态码 + 原因短语</span><br></pre></td></tr></table></figure><p>当使用的是<code>GET</code> 方法的时候， body是为空的。<br>比如如下图<br>我们打开Fiddler 捕捉一个网页的Request 然后分析下它的结构, 在Inspectors tab下以<strong>Raw</strong>的方式可以看到完整的Request的消息<br><img src="https://img-blog.csdnimg.cn/20200419134127301.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyYWN5X2Zyb2c=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="二、HTTP首部"><a href="#二、HTTP首部" class="headerlink" title="二、HTTP首部"></a>二、HTTP首部</h2><p>一般有4种首部，分别是通用首部、请求首部、响应首部和实体首部。</p><h3 id="1-通用首部字段"><a href="#1-通用首部字段" class="headerlink" title="1. 通用首部字段"></a>1. 通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="==Cache-Control=="></a>==Cache-Control==</h4><p>作用：<br><code> 这个是非常重要的规则</code>，用于控制缓存的行为。 这个用来指定Response-Request遵循的<code>缓存机制</code>。各个指令含义如下<br><code>Cache-Control:Public</code>   可以被任何缓存所缓存（）<br><code>Cache-Control:Private</code>     内容只缓存到私有缓存中<br><code>Cache-Control:no-cache</code>  所有内容都不会被缓存<br>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="==Connection=="></a>==Connection==</h4><p>例如：<code>Connection: keep-alive</code>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br>例如： <code>Connection: close</code>  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><h4 id="Date"><a href="#Date" class="headerlink" title="==Date=="></a>==Date==</h4><p>作用:  生成消息的具体时间和日期<br>例如：Date: Sat, 11 Feb 2012 11:35:14 GMT </p><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>作用：防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样<br>Pargma只有一个用法， 例如： Pragma: no-cache</p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>作用：报文末端的首部一览</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>作用：指定报文主体的传输编码方式</p><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p><strong>作用</strong>：升级为其他协议</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>作用：代理服务器的相关信息</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>作用：错误通知</p><h3 id="2-请求首部字段"><a href="#2-请求首部字段" class="headerlink" title="2. 请求首部字段"></a>2. 请求首部字段</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="==Accept=="></a>==Accept==</h4><p>作用： 浏览器端可以接受的<code>媒体类型</code><br>例如：  <code>Accept: text/html</code>  代223表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,<br>如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(not acceptable)<br>通配符 <code>*</code> 代表任意类型<br>例如  <code>Accept: */* </code> 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="==Accept-Charset=="></a>==Accept-Charset==</h4><p>作用：<code>浏览器申明自己接收的字符集</code>，这就是本文前面介绍的各种字符集和字符编码，如<code>gb2312，utf-8</code>（通常我们说Charset包括了相应的字符编码方案）；</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="==Accept-Encoding=="></a>==Accept-Encoding==</h4><p>作用： <code>浏览器申明自己接收的编码方法</code>，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;<br>例如： Accept-Encoding: gzip, deflate</p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="==Accept-Language=="></a>==Accept-Language==</h4><p>作用： <code>浏览器申明自己接收的语言</code>。<br>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；<br>例如： Accept-Language: en-us</p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="==Authorization=="></a>==Authorization==</h4><p>作用：Web认证信息。</p><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><p>作用：期待服务器的特定行为。</p><h4 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h4><p>作用：用户的电子邮箱地址</p><h4 id="Host（发送请求时，该报头域是必需的）"><a href="#Host（发送请求时，该报头域是必需的）" class="headerlink" title="==Host（发送请求时，该报头域是必需的）=="></a>==Host（发送请求时，该报头域是必需的）==</h4><p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的<br>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：<a href="http://www.guet.edu.cn/">http://www.guet.edu.cn</a><br>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>作用：比较实体标记（Etag）</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="==If-Modified-Since=="></a>==If-Modified-Since==</h4><p>作用：比较资源的更新时间</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>作用：比较实体标记（与If-Match相反）</p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>作用：资源未更新时发送实体Byte的范围请求</p><h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p>作用：比较资源的更新时间（与If-Modified-Since相反）</p><h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p>作用：最大传输逐跳数</p><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>作用：代理服务器要求客户端的认证信息</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>作用：实体的字节范围请求</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="==Referer=="></a>==Referer==</h4><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。<br>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><p>作用：传输编码的优先级</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="==User-Agent=="></a>==User-Agent==</h4><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。<br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的<code>操作系统的名称和版本</code>，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域<code>允许客户端将它的操作系统、浏览器和其它属性告诉服务器</code>。<br>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p><h3 id="3-响应首部字段"><a href="#3-响应首部字段" class="headerlink" title="3. 响应首部字段"></a>3. 响应首部字段</h3><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>作用：是否接受字节范围请求</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>作用：推算资源创建经过时间</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>作用：资源的匹配信息</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>作用：令客户端重定向至指定URI</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>作用：代理服务器对客户端的认证信息</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p>作用：对再次发起请求的时机要求</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>作用：指明HTTP服务器的软件信息<br>例如:Server: Microsoft-IIS/7.5</p><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>作用：代理服务器缓存的管理信息</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><p>作用：服务器对客户端的认证信息</p><h3 id="4-实体首部字段"><a href="#4-实体首部字段" class="headerlink" title="4. 实体首部字段"></a>4. 实体首部字段</h3><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>作用：资源可支持的http方法</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="==Content-Type=="></a>==Content-Type==</h4><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,<br>例如:<br>Content-Type: text/html; charset=utf-8<br>Content-Type:text/html;charset=GB2312<br>Content-Type: image/jpeg</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p><p>例如: Content-Length: 19847</p><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><p>作用：实体主体的自然语言。</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><p>作用：替代对应资源的URI。</p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><p>作用：实体主体的报文摘要。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p>作用：实体主体的位置范围。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>作用：实体主体适用的编码方式。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>作用： <strong>最重要的header</strong>, 将cookie的值发送给HTTP 服务器</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="==Expires=="></a>==Expires==</h4><p>作用: 浏览器会在指定<strong>过期时间</strong>内使用本地缓存<br>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="==Last-Modified=="></a>==Last-Modified==</h4><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）<br>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p><h4 id="X-AspNet-Version"><a href="#X-AspNet-Version" class="headerlink" title="X-AspNet-Version"></a>X-AspNet-Version</h4><p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本<br>例如: X-AspNet-Version: 4.0.30319</p><h4 id="X-Powered-By"><a href="#X-Powered-By" class="headerlink" title="X-Powered-By"></a>X-Powered-By</h4><p>作用：表示网站是用什么技术开发的<br>例如： X-Powered-By: ASP.NET</p><h2 id="三、-浏览器缓存"><a href="#三、-浏览器缓存" class="headerlink" title="三、 浏览器缓存"></a>三、 浏览器缓存</h2><p><a href="https://blog.csdn.net/eroswang/article/details/8302191">浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</a><br><a href="https://juejin.im/post/6844904133024022536#heading-9">轻松理解浏览器缓存（Koa缓存源码解析）</a><br><a href="https://juejin.im/post/6844903873333870600#heading-0">通过 koa2 服务器实践探究浏览器HTTP缓存机制</a></p><p><code>当我们不设置cache-control，只设置协商缓存，在不同浏览器下会有不同的表现。 亲测chrome、firefox、360极速模式会直接从本地缓存获取，其他（360兼容模式、IE浏览器、Microsoft Edge）会请求服务器返回304.</code></p>]]></content>
    
    
    <summary type="html">http协议请求报文和响应报文</summary>
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>CSS3——CSS3矩阵matrix进行2D变换的数学原理</title>
    <link href="http://example.com/2020/12/23/CSS3%E2%80%94%E2%80%94CSS3%E7%9F%A9%E9%98%B5matrix%E8%BF%9B%E8%A1%8C2D%E5%8F%98%E6%8D%A2%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2020/12/23/CSS3%E2%80%94%E2%80%94CSS3%E7%9F%A9%E9%98%B5matrix%E8%BF%9B%E8%A1%8C2D%E5%8F%98%E6%8D%A2%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-23T11:32:10.000Z</published>
    <updated>2020-12-28T06:36:13.069Z</updated>
    
    <content type="html"><![CDATA[<p>css3的2D转换中matrix接受6个参数，却可以实现平移、旋转、放缩、斜切四种效果。它是如何做到的呢？</p><p>此处的你有两个选择<br>0 - 对自己有较高要求！老老实实静下心来将本文看完，<br>1 - 直接看总结——<a href="#declude">点我直达</a>，只学习如何使用matrix</p><p><code>预备知识</code>：矩阵相乘、三角函数，fighting！</p><p>此处附上矩阵相乘的<code>百度百科</code>定义<br><img src="https://img-blog.csdn.net/20181004234034404" alt="在这里插入图片描述"><br>我们先将matrix接受的六个参数记为a,b,c,d,e,f，则该变换矩阵记为<br><img src="https://img-blog.csdn.net/20181004124755430" alt="在这里插入图片描述"><br>二维平面上一个点记为（x,y），为了与<code>向量</code>区分开，我们使用数字<code>1</code>代表点，<code>0</code>代表向量，则二维平面上一个点应记为（x,y,1），为了使该点经过变换后依旧为（x,y,1）的形式，矩阵可以改为<br><img src="https://img-blog.csdn.net/20181004125031854" alt="在这里插入图片描述"><br>进行相乘变换（自行百度矩阵相乘的公式）<br><img src="https://img-blog.csdn.net/2018100412555912" alt="在这里插入图片描述"><br>我们得到了一个新的点（ax+cy+e,bx+dy+f,1）<br>怎么将这个冷冰冰的点和我们的平移旋转缩放斜切联系到一起呢？</p><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>我们知道，对一个点（x,y,1）向x轴正向平移10,向y轴正向平移20，得到的点为（x+10,y+20,1），而经过矩阵变换的点为（ax+cy+e,bx+dy+f,1），对比得到a=1,c=0,e=10,b=0,d=1,f=20<br>所以变换矩阵为<br><img src="https://img-blog.csdn.net/20181004130234876" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(1,0,0,1,10,20); &#x2F;&#x2F; a&#x3D;1,c&#x3D;0,e&#x3D;10,b&#x3D;0,d&#x3D;1,f&#x3D;20</span><br></pre></td></tr></table></figure><p>显然，与平移变换直接相关的参数为<code>e、f</code>参数！！<br>当我们只进行平移变换时，只需要这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(1,0,0,1,e,f); &#x2F;&#x2F; 相当于 transform: translate(e,f);</span><br></pre></td></tr></table></figure><h2 id="放缩"><a href="#放缩" class="headerlink" title="放缩"></a>放缩</h2><p>假设我们对一个边长为10px的正方形放大2倍，如图所示<br><img src="https://img-blog.csdn.net/20181004132658994" alt="在这里插入图片描述"><br>对左上角的那个点来说，它由（0，10，1）变为（0，20，1）<br>对任意一个点（x,y,1）来说，放大后得到的点为（2x,2y,1），而经过矩阵变换的点为（ax+cy+e,bx+dy+f,1），对比得到a=2,c=0,e=0,b=0,d=2,f=0<br>所以变换矩阵为<br><img src="https://img-blog.csdn.net/20181004132942603" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(2,0,0,2,0,0); &#x2F;&#x2F; a&#x3D;2,c&#x3D;0,e&#x3D;0,b&#x3D;0,d&#x3D;2,f&#x3D;0</span><br></pre></td></tr></table></figure><p>显然，与缩放变换直接相关的参数为<code>a、d</code>参数！！<br>当我们只进行平移变换时，只需要这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(a,0,0,d,0,0); &#x2F;&#x2F; 相当于 transform: scale(a,d)</span><br></pre></td></tr></table></figure><p>聪明的你现在肯定猜到了，如果既进行平移，又进行缩放，则<code>transform: matrix(a,0,0,d,e,f);</code>即可，a、d表示缩放，e、f表示平移</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>剩下两个参数b、c，可是还有旋转和斜切没有实现呢！（冒汗<br>旋转的话，涉及到旋转角度的问题啦。记为θ。<br>复习一波三角函数，以下使用<code>极坐标</code>表示<br><img src="https://img-blog.csdn.net/20181004140339439" alt="在这里插入图片描述"><br>来一波推理<br><img src="https://img-blog.csdn.net/20181004141052662" alt="在这里插入图片描述"><br>对任意一个点（x,y,1）来说，旋转θ°后得到的点为（xcosθ-ysinθ，xsinθ+ycosθ,1），而经过矩阵变换的点为（ax+cy+e,bx+dy+f,1），对比得到a=cosθ，b=sinθ，c=-sinθ，d=cosθ，e=0，f=0<br>所以变换矩阵为<br><img src="https://img-blog.csdn.net/20181004141522675" alt="在这里插入图片描述"><br>这里用到了a、b、c、d四个参数，前面我们知道缩放用了a、d两个参数，如果我们既要旋转又要缩放怎么办呢？？</p><blockquote><p>已经证明：任何二维组合变换均可分解为多个基本变换的乘积</p></blockquote><p>故我们只需要分别求出变换矩阵，再<code>相乘</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q&#x3D;DCBAp &#x3D;&gt; q&#x3D;(DCBA)p&#x3D;Mp</span><br></pre></td></tr></table></figure><p>解释：p表示当前的点，ABCD表示四种变换，上述式子的变换顺序为A-&gt;B-&gt;C-&gt;D</p><h2 id="斜切"><a href="#斜切" class="headerlink" title="斜切"></a>斜切</h2><p>先沿x轴扭曲<br><img src="https://img-blog.csdn.net/20181005120345938" alt="在这里插入图片描述"><br>有以下式子<br><img src="https://img-blog.csdn.net/20181005120547742" alt="在这里插入图片描述"><br>与(ax+cy+e,bx+dy+f,1)对比得出a=1，c=tanθ，e=0，b=0，d=1，f=0<br>所以变换矩阵为<br><img src="https://img-blog.csdn.net/20181005120823504" alt="在这里插入图片描述"><br>再看沿y轴扭曲<br><img src="https://img-blog.csdn.net/20181005121547189" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181005121608273" alt="在这里插入图片描述"><br>变换矩阵为<br><img src="https://img-blog.csdn.net/20181005122453834" alt="在这里插入图片描述"><br>当l种变换同时进行时，有<br><img src="https://img-blog.csdn.net/20181005130855380" alt="在这里插入图片描述"><br>【思考】我们之前说过，任何二维组合变换均可分解为多个基本变换的乘积，为什么这里不是将两个扭曲矩阵相乘呢？（先沿x轴扭曲，再沿y轴扭曲？<br>emmm，是这样的，我们这里的计算都是相对<code>最初始</code>的图形，如果用两个矩阵相乘，则是使初始图形沿x轴扭曲θx度后得到的<code>新图形</code>再对y轴扭曲θy度！！如果要达到我们想要的效果，就只能重新计算沿y轴的扭曲角度！！</p><p>【<span id="declude">总结</span>】<br>至此我们已经把2D变换的数学原理挖出来了，写一个用法总结，便于自己查找也便于大家查看</p><ul><li>平移，只需要控制最后两个参数e、f，a、d参数为1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(1,0,0,1,e,f);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">transform: translate(e,f);</span><br></pre></td></tr></table></figure></li><li>放缩，只需要控制a、d参数，其它为0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(a,0,0,d,0,0); </span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">transform: scale(a,d);</span><br></pre></td></tr></table></figure></li><li>旋转，只需要控制a、b、c、d参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(cosθ, sinθ, -sinθ, cosθ)；</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">rtransform: rotate(θdeg)</span><br></pre></td></tr></table></figure></li><li>斜切<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(1, tanθy, tanθx, 1, 0, 0);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">transform: skew(θx, θy);</span><br></pre></td></tr></table></figure></li><li>复合变换<br>如以下这种类型，先旋转再缩放再扭曲，如何用矩阵得到呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(360deg) scale(2,2) skew(10deg,5deg);</span><br></pre></td></tr></table></figure><blockquote><p>已经证明：任何二维组合变换均可分解为多个基本变换的乘积<br>故我们先求出旋转矩阵A，缩放矩阵B和斜切矩阵C<br>最后得到变换矩阵M = CBA = C(B(A))</p></blockquote></li></ul><p>【什么时候我们用矩阵？】<br>思考下，既然已经有rotate、scale等函数，直接调用不就行了吗？？为什么人类要跟自己过不去，手算矩阵？？？<br>大部分情况下，当然是使用那些基本的rotate、scale函数就好了，下面这种类型的情况呢？</p><ul><li>需求说：请把这些点沿着y轴取对称。 你：简单<br>x’ = ax+cy+e = -x，y’ = bx+dy+f = y嘛，一番心算后你得到  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(-1,0,0,1,0,0);</span><br></pre></td></tr></table></figure></li><li>需求说：算了，还是对y=x取对称吧。你：简单，先整体旋转<code>逆时针</code>旋转45°，再对y轴取对称，再整体<code>顺时针</code>旋转45°（45°）就好了嘛~<br><img src="https://img-blog.csdn.net/20181005144032545" alt="在这里插入图片描述"><br>  (上图右侧表示逆时针旋转)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: matrix(0,1,1,0,0,0);</span><br></pre></td></tr></table></figure>  用我们的高中数学来验证一波，点(a,b)关于y=x轴取对称，得到的点应该为（b,a）<br>  <img src="https://img-blog.csdn.net/2018100514435764" alt="在这里插入图片描述"><br>  验证正确！</li><li>需求犹豫了0.5s，哎呀还是对y=kx取对称吧…</li><li>需求摇摇头说，对y=kx+b取对称吧….</li></ul><p>此处插播高中知识——如何关于一条直线取对称点呢？</p><ol><li>两个点关于一条直线对称，那么这两个点的连线的中点必在该直线上</li><li>两个点的连线所在直线的斜率与该直线斜率的乘积为-1（因为垂直）</li><li>可以列出两个方程，求出对称点！</li><li>对称点都求出来了，矩阵也就出来了~</li></ol><ul><li>现在请看官使用rotate、scale、skew、translate实现上述需求~</li></ul><p>【demo】<a href="http://www.wukai.me/2015/10/22/css3-cube/">使用css3画一个立方体</a></p><p>【参考】<br><a href="https://www.atjiang.com/css-transform-skew-angle/">https://www.atjiang.com/css-transform-skew-angle/</a><br><a href="http://0313.name/archives/66">http://0313.name/archives/66</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/">https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/</a><br><a href="http://www.wukai.me/2015/10/22/css3-cube/">http://www.wukai.me/2015/10/22/css3-cube/</a></p>]]></content>
    
    
    <summary type="html">css3的2D转换中matrix接受6个参数，却可以实现平移、旋转、放缩、斜切四种效果。它是如何做到的呢？</summary>
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css3" scheme="http://example.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/23/hello-world/"/>
    <id>http://example.com/2020/12/23/hello-world/</id>
    <published>2020-12-23T10:15:49.795Z</published>
    <updated>2020-12-23T10:15:49.795Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
